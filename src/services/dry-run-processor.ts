import { existsSync } from 'node:fs';
import { stat } from 'node:fs/promises';
import { dirname, basename, resolve, relative } from 'node:path';
import type { Logger } from '../utils/logger.ts';

/**
 * Options for dry-run analysis
 */
export interface DryRunOptions {
  showFileDetails: boolean;
  estimateTime: boolean;
  checkFileAccess: boolean;
  groupByDirectory: boolean;
  showProcessingOrder: boolean;
}

/**
 * Default dry-run options
 */
export const DEFAULT_DRY_RUN_OPTIONS: DryRunOptions = {
  showFileDetails: true,
  estimateTime: true,
  checkFileAccess: true,
  groupByDirectory: true,
  showProcessingOrder: false
};

/**
 * Analysis plan generated by dry-run
 */
export interface AnalysisPlan {
  totalFiles: number;
  filesByDirectory: Map<string, string[]>;
  estimatedDuration: number;
  potentialIssues: string[];
  processingOrder: string[];
  skippedFiles: Array<{ file: string; reason: string }>;
  fileDetails: Array<{
    file: string;
    size: number;
    estimatedTime: number;
    accessible: boolean;
    directory: string;
  }>;
  summary: {
    totalSize: number;
    averageFileSize: number;
    largestFile: { file: string; size: number } | null;
    smallestFile: { file: string; size: number } | null;
    directoryCount: number;
  };
}

/**
 * File analysis details for dry-run
 */
export interface FileAnalysisDetails {
  file: string;
  size: number;
  estimatedTime: number;
  accessible: boolean;
  directory: string;
  exists: boolean;
  isReadable: boolean;
  lastModified?: Date;
}

/**
 * Dry-run processor for analyzing files before processing
 */
export class DryRunProcessor {
  private logger: Logger;
  private analyzer: DryRunAnalyzer;

  constructor(logger: Logger) {
    this.logger = logger.child('DryRunProcessor');
    this.analyzer = new DryRunAnalyzer(logger);
  }

  /**
   * Perform dry-run analysis on a list of files
   */
  async analyzePlan(files: string[], options: DryRunOptions = DEFAULT_DRY_RUN_OPTIONS): Promise<AnalysisPlan> {
    this.logger.info(`Starting dry-run analysis for ${files.length} files`);
    
    const plan = await this.analyzer.createAnalysisPlan(files, options);
    
    this.logger.info(`Dry-run analysis completed: ${plan.totalFiles} files, ${plan.skippedFiles.length} skipped`);
    
    return plan;
  }

  /**
   * Display the analysis plan in a formatted way
   */
  showPlan(plan: AnalysisPlan, options: DryRunOptions = DEFAULT_DRY_RUN_OPTIONS): void {
    this.analyzer.displayPlan(plan, options);
  }

  /**
   * Validate files for processing
   */
  async validateFiles(files: string[]): Promise<{
    valid: string[];
    invalid: Array<{ file: string; reason: string }>;
  }> {
    const valid: string[] = [];
    const invalid: Array<{ file: string; reason: string }> = [];

    for (const file of files) {
      try {
        const details = await this.analyzer.analyzeFile(file);
        
        if (!details.exists) {
          invalid.push({ file, reason: 'File does not exist' });
        } else if (!details.accessible) {
          invalid.push({ file, reason: 'File is not accessible' });
        } else if (!details.isReadable) {
          invalid.push({ file, reason: 'File is not readable' });
        } else {
          valid.push(file);
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        invalid.push({ file, reason: `Analysis failed: ${errorMessage}` });
      }
    }

    return { valid, invalid };
  }

  /**
   * Get processing time estimates for files
   */
  async getTimeEstimates(files: string[]): Promise<Map<string, number>> {
    const estimates = new Map<string, number>();

    for (const file of files) {
      try {
        const details = await this.analyzer.analyzeFile(file);
        estimates.set(file, details.estimatedTime);
      } catch (error) {
        this.logger.warn(`Failed to estimate time for ${file}: ${error}`);
        estimates.set(file, 0);
      }
    }

    return estimates;
  }
}

/**
 * Dry-run analyzer for detailed file analysis
 */
export class DryRunAnalyzer {
  private logger: Logger;
  
  // Time estimation constants (in milliseconds)
  private static readonly BASE_PROCESSING_TIME = 1000; // 1 second base time
  private static readonly TIME_PER_KB = 10; // 10ms per KB
  private static readonly MIN_PROCESSING_TIME = 500; // 0.5 seconds minimum
  private static readonly MAX_PROCESSING_TIME = 30000; // 30 seconds maximum

  constructor(logger: Logger) {
    this.logger = logger.child('DryRunAnalyzer');
  }

  /**
   * Create a comprehensive analysis plan
   */
  async createAnalysisPlan(files: string[], options: DryRunOptions): Promise<AnalysisPlan> {
    const plan: AnalysisPlan = {
      totalFiles: 0,
      filesByDirectory: new Map(),
      estimatedDuration: 0,
      potentialIssues: [],
      processingOrder: [],
      skippedFiles: [],
      fileDetails: [],
      summary: {
        totalSize: 0,
        averageFileSize: 0,
        largestFile: null,
        smallestFile: null,
        directoryCount: 0
      }
    };

    const fileSizes: number[] = [];

    for (const file of files) {
      try {
        const details = await this.analyzeFile(file);
        
        if (!details.exists) {
          plan.skippedFiles.push({ file, reason: 'File does not exist' });
          continue;
        }

        if (options.checkFileAccess && !details.accessible) {
          plan.skippedFiles.push({ file, reason: 'File not accessible' });
          continue;
        }

        if (!details.isReadable) {
          plan.skippedFiles.push({ file, reason: 'File not readable' });
          continue;
        }

        // Add to plan
        plan.fileDetails.push({
          file: details.file,
          size: details.size,
          estimatedTime: details.estimatedTime,
          accessible: details.accessible,
          directory: details.directory
        });

        // Group by directory
        if (options.groupByDirectory) {
          if (!plan.filesByDirectory.has(details.directory)) {
            plan.filesByDirectory.set(details.directory, []);
          }
          plan.filesByDirectory.get(details.directory)!.push(file);
        }

        // Update summary statistics
        plan.summary.totalSize += details.size;
        fileSizes.push(details.size);

        if (!plan.summary.largestFile || details.size > plan.summary.largestFile.size) {
          plan.summary.largestFile = { file, size: details.size };
        }

        if (!plan.summary.smallestFile || details.size < plan.summary.smallestFile.size) {
          plan.summary.smallestFile = { file, size: details.size };
        }

        // Add to processing order
        plan.processingOrder.push(file);
        plan.totalFiles++;

        // Estimate processing time
        if (options.estimateTime) {
          plan.estimatedDuration += details.estimatedTime;
        }

      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        plan.skippedFiles.push({ file, reason: `Analysis failed: ${errorMessage}` });
        this.logger.warn(`Failed to analyze ${file}: ${errorMessage}`);
      }
    }

    // Calculate summary statistics
    plan.summary.averageFileSize = plan.totalFiles > 0 ? plan.summary.totalSize / plan.totalFiles : 0;
    plan.summary.directoryCount = plan.filesByDirectory.size;

    // Detect potential issues
    plan.potentialIssues = this.detectPotentialIssues(plan);

    return plan;
  }

  /**
   * Analyze a single file for dry-run
   */
  async analyzeFile(filePath: string): Promise<FileAnalysisDetails> {
    const resolvedPath = resolve(filePath);
    const directory = dirname(resolvedPath);
    
    const details: FileAnalysisDetails = {
      file: filePath,
      size: 0,
      estimatedTime: 0,
      accessible: false,
      directory: relative(process.cwd(), directory),
      exists: false,
      isReadable: false
    };

    try {
      // Check if file exists
      details.exists = existsSync(resolvedPath);
      
      if (!details.exists) {
        return details;
      }

      // Get file stats
      const stats = await stat(resolvedPath);
      details.size = stats.size;
      details.lastModified = stats.mtime;
      details.isReadable = true; // If we can stat it, we can likely read it
      details.accessible = true;

      // Estimate processing time based on file size
      details.estimatedTime = this.estimateProcessingTime(details.size);

    } catch (error) {
      this.logger.debug(`Error analyzing file ${filePath}: ${error}`);
      details.accessible = false;
      details.isReadable = false;
    }

    return details;
  }

  /**
   * Estimate processing time based on file size
   */
  private estimateProcessingTime(sizeInBytes: number): number {
    const sizeInKB = sizeInBytes / 1024;
    const estimatedTime = DryRunAnalyzer.BASE_PROCESSING_TIME + (sizeInKB * DryRunAnalyzer.TIME_PER_KB);
    
    // Clamp to min/max bounds
    return Math.max(
      DryRunAnalyzer.MIN_PROCESSING_TIME,
      Math.min(DryRunAnalyzer.MAX_PROCESSING_TIME, estimatedTime)
    );
  }

  /**
   * Detect potential issues with the analysis plan
   */
  private detectPotentialIssues(plan: AnalysisPlan): string[] {
    const issues: string[] = [];

    // Check for large files that might take a long time
    const largeFiles = plan.fileDetails.filter(f => f.size > 1024 * 1024); // > 1MB
    if (largeFiles.length > 0) {
      issues.push(`${largeFiles.length} large files detected (>1MB) - processing may take longer`);
    }

    // Check for very long estimated duration
    if (plan.estimatedDuration > 300000) { // > 5 minutes
      issues.push(`Estimated processing time is ${this.formatDuration(plan.estimatedDuration)} - consider parallel processing`);
    }

    // Check for many files in a single directory
    for (const [dir, files] of plan.filesByDirectory) {
      if (files.length > 50) {
        issues.push(`Directory ${dir} contains ${files.length} files - consider breaking into smaller batches`);
      }
    }

    // Check for skipped files
    if (plan.skippedFiles.length > 0) {
      issues.push(`${plan.skippedFiles.length} files will be skipped due to accessibility issues`);
    }

    // Check for empty directories
    const emptyDirs = Array.from(plan.filesByDirectory.entries()).filter(([, files]) => files.length === 0);
    if (emptyDirs.length > 0) {
      issues.push(`${emptyDirs.length} directories contain no processable files`);
    }

    return issues;
  }

  /**
   * Display the analysis plan in a formatted way
   */
  displayPlan(plan: AnalysisPlan, options: DryRunOptions): void {
    console.log('\n🔍 Analysis Plan (Dry Run)');
    console.log('═'.repeat(60));
    
    // Summary section
    console.log(`📊 Total files to analyze: ${plan.totalFiles}`);
    console.log(`📁 Directories: ${plan.summary.directoryCount}`);
    console.log(`📦 Total size: ${this.formatFileSize(plan.summary.totalSize)}`);
    console.log(`📈 Average file size: ${this.formatFileSize(plan.summary.averageFileSize)}`);
    
    if (options.estimateTime) {
      console.log(`⏱️  Estimated duration: ${this.formatDuration(plan.estimatedDuration)}`);
    }

    // Largest and smallest files
    if (plan.summary.largestFile) {
      console.log(`📄 Largest file: ${plan.summary.largestFile.file} (${this.formatFileSize(plan.summary.largestFile.size)})`);
    }
    if (plan.summary.smallestFile) {
      console.log(`📄 Smallest file: ${plan.summary.smallestFile.file} (${this.formatFileSize(plan.summary.smallestFile.size)})`);
    }

    // Skipped files
    if (plan.skippedFiles.length > 0) {
      console.log(`\n⚠️  Skipped files: ${plan.skippedFiles.length}`);
      plan.skippedFiles.forEach(({ file, reason }) => {
        console.log(`   • ${file} (${reason})`);
      });
    }

    // Files by directory
    if (options.groupByDirectory && plan.filesByDirectory.size > 0) {
      console.log('\n📁 Files by directory:');
      for (const [dir, files] of plan.filesByDirectory) {
        const dirSize = files.reduce((sum, file) => {
          const details = plan.fileDetails.find(d => d.file === file);
          return sum + (details?.size || 0);
        }, 0);
        
        console.log(`   ${dir}/ (${files.length} files, ${this.formatFileSize(dirSize)})`);
        
        if (options.showFileDetails) {
          files.forEach(file => {
            const details = plan.fileDetails.find(d => d.file === file);
            if (details) {
              const timeStr = options.estimateTime ? `, ~${this.formatDuration(details.estimatedTime)}` : '';
              console.log(`     • ${basename(file)} (${this.formatFileSize(details.size)}${timeStr})`);
            }
          });
        }
      }
    }

    // Processing order
    if (options.showProcessingOrder && plan.processingOrder.length > 0) {
      console.log('\n📋 Processing order:');
      plan.processingOrder.forEach((file, index) => {
        console.log(`   ${index + 1}. ${file}`);
      });
    }

    // Potential issues
    if (plan.potentialIssues.length > 0) {
      console.log('\n⚠️  Potential issues:');
      plan.potentialIssues.forEach(issue => {
        console.log(`   • ${issue}`);
      });
    }

    // Summary footer
    console.log('\n' + '═'.repeat(60));
    console.log(`✅ Ready to process ${plan.totalFiles} files`);
    if (plan.skippedFiles.length > 0) {
      console.log(`⚠️  ${plan.skippedFiles.length} files will be skipped`);
    }
    console.log('');
  }

  /**
   * Format file size in human-readable format
   */
  private formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 B';
    
    const units = ['B', 'KB', 'MB', 'GB'];
    const k = 1024;
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return `${(bytes / Math.pow(k, i)).toFixed(1)} ${units[i]}`;
  }

  /**
   * Format duration in human-readable format
   */
  private formatDuration(milliseconds: number): string {
    if (milliseconds < 1000) {
      return `${milliseconds}ms`;
    }
    
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    if (hours > 0) {
      const remainingMinutes = minutes % 60;
      const remainingSeconds = seconds % 60;
      return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;
    } else if (minutes > 0) {
      const remainingSeconds = seconds % 60;
      return `${minutes}m ${remainingSeconds}s`;
    } else {
      return `${seconds}s`;
    }
  }

  /**
   * Check if a file can be accessed for reading
   */
  async canAccessFile(filePath: string): Promise<boolean> {
    try {
      const resolvedPath = resolve(filePath);
      
      if (!existsSync(resolvedPath)) {
        return false;
      }

      await stat(resolvedPath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Group files by directory
   */
  groupFilesByDirectory(files: string[]): Map<string, string[]> {
    const groups = new Map<string, string[]>();
    
    for (const file of files) {
      const dir = relative(process.cwd(), dirname(resolve(file)));
      
      if (!groups.has(dir)) {
        groups.set(dir, []);
      }
      groups.get(dir)!.push(file);
    }
    
    return groups;
  }

  /**
   * Sort files by processing priority (size, type, etc.)
   */
  sortFilesByPriority(files: string[], fileDetails: Map<string, FileAnalysisDetails>): string[] {
    return files.sort((a, b) => {
      const detailsA = fileDetails.get(a);
      const detailsB = fileDetails.get(b);
      
      if (!detailsA || !detailsB) {
        return 0;
      }
      
      // Sort by size (smaller files first for faster feedback)
      return detailsA.size - detailsB.size;
    });
  }
}